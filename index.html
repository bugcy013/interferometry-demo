<html lang="en">
<head>
  <title>Introduction to Interferometry and Synthesis Imaging</title>


  <!-- Styling -->
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='html.css' rel='stylesheet' type='text/css'>

  <!-- JavaScript -->
  <!-- CSS is loaded before JavaScript in order to improve user experience -->
  <link href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700' rel='stylesheet' type='text/css'>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script type="text/javascript"
          src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.transit/0.9.12/jquery.transit.min.js"></script>


  <link rel="stylesheet" href="thebe.css" type="text/css"/>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="https://rawgit.com/oreillymedia/thebe/master/static/main-built.js" type="text/javascript" charset="utf-8"></script>
</head>
<body>


<body>

<section id="content">

<section id="content-body">


<h1 id="introduction-to-interferometry-and-synthesis-imaging">Introduction to Interferometry and Synthesis Imaging</h1>

<p>Before you can use the interactive examples, you ned to load a few modules and set up the environment.  So, click the "Run" button.</p>

<pre data-code-language="python" data-executable="true">
%matplotlib inline
from IPython.display import Image
from IPython.html.widgets import interact
from numpy import pi, cos, sin
import numpy as np
import pylab as plt
</pre>

<p>A radio interferometer computes pair-wise correlations between antennas.</p>
<p><em>Text to explain interferometer in more detail here. The notebook is designed to support the textbook, so will refer extensively to it.</em></p>


<img src="interferometer.png"/>

<p><strong>Fig 1:</strong> Geometry of an elementary three-element interfometer. Three antennas (elements) are arranged in a line with a spacing $b$ between them. The correlator computes a moving average of all pairwise products of voltages from antenna elements.</p>

<h2 id="fringe-frequency">Fringe frequency</h2>

<p>Consider the simple interferometer shown in Fig. 1, and its response to a single, very distant point source of radiation.</p>

<p>The wavefront from the source in direction $\theta$ reaches the right-hand antenna at a
time $\tau_{g}=(2b/c)sin\theta$ before it reaches the left-hand one. $\tau_g$ is called the <em>geometric delay</em> and $c$ is the speed of light. A correlator computes the product $<V_n V_m^*>$, between antennas $n$ and $m$.</p>

<p>The "fringe function" $F$ is given by Eq. 2.2 in your textbook:</p>

<p>$$F = cos2\pi\nu\tau_g=cos(\frac{2\pi b l}{\pi})$$</p>

<p>Where $l=sin(\theta)$. Here, $\theta$ is the "pointing angle" of the telescope.</p>

<p>As the point source transits across the sky, the value of $\theta$ changes and the fringe function will respond accordingly:</p>

<pre data-code-language="python" data-executable="true">
def plot_fringe(bl_length, wavelength):
    """ Plot the fringe function for a baseline """
    theta = np.linspace(-np.pi, np.pi, 201)
    l = sin(theta)
    F = cos(2 * pi * bl_length * l / wavelength)
    F2 = cos(2 * pi * 2 * bl_length * l / wavelength)

    plt.plot(l, F, c='#cc0000', label="Baseline 1-2")
    plt.plot(l, F2, c='#0000cc', label="Baseline 1-3")
    plt.xlabel("$sin(\\theta)$")
    plt.ylabel("Fringe amplitude")
    plt.ylim(-2, 2)
    plt.legend()

interact(plot_fringe, bl_length=(1, 100), wavelength=(1, 100))
</pre>

<p>We see that as baseline increases, the fringe function oscillates more rapidly.</p>

<p>What if we have many different baselines?</p>

<p>...</p>

<h2 id="correlator-computations">Correlator computations</h2>

<p>Pairwise correlation of all antennas is an $O(N^2)$ operation, meaning that as the number of antennas $N$ increases, the number of computations required increases in proportion to $N^2$.</p>

<p>More precisely, the number of possible pairs of antennas (counting pairing with themselves) is given by</p>

<p>$$ N_{pairs} = \frac{(N_{ant})(N_{ant} + 1)}{2}.$$</p>

<p>The number of computation operations required per second (measured in FLOP/s) also depends upon the bandwidth of the digitized signals. The widget below computes the number of FLOP/s a correlator would need for a given bandwidth and number of antennas:</p>

<pre data-code-language="python" data-executable="true">
tflops_per_gpu = 1.5     # TFLOP/s achievable on a single GPU, NVIDIA GTX960
cost_per_gpu   = 250.0   # Cost per GPU

def n_ops(bandwidth, n_ant):
    n_baselines = (n_ant*2) * (n_ant*2 + 1) / 2 # Dual-pol + autocorrelations
    mult_per_sec = n_baselines * bandwidth
    tflops_per_sec = mult_per_sec * 4 / 1e6
    n_gpu = np.ceil(tflops_per_sec / tflops_per_gpu)

    to_print =  "Bandwidth:                  %s MHz\n" % bandwidth
    to_print += "Number of antennas:         %i\n" % n_ant
    to_print += "Number of baselines:        %i\n" % n_baselines
    to_print += "Correlator computations:    %2.3f TFLOP/s\n" % tflops_per_sec
    to_print += "Number of GPUs required:    %i" % n_gpu
    print to_print

interact(n_ops, bandwidth=(1, 1e3), n_ant=(1, 1024))
</pre>

<script>
$(function(){
  new Thebe({
	url:"https://tmp33.tmpnb.org", 
	kernel_name: "python2"
	});
});
</script>

</section>
</section>


 </body>
</html>
